<?php

/**
 *                                Apache License
 *                          Version 2.0, January 2004
 *                       http://www.apache.org/licenses/
 *
 * Description of Chrysalis:
 * 
 * Chrysalis is a lib to check a database model and
 * generate clases based on it.
 *
 * @author pabhoz
 * @version 1.0.0
 * githut: @pabhoz
 * bitbucket: @pabhoz
 * 
 */

require_once "Database.php";
require_once "Table.php";

class Chrysalis{
    
    protected $version = "1.0.0";

    private $dsn;
    private $db_name;
    private $db_user;
    private $db_pass;
    private $host;
    private $driver;
    private $conn;
    public $tables;
    
    public function __construct($host, $db_name, $db_user, $db_pass, $driver = "mysql") {
        $this->dsn = $driver.':host='.$host.';dbname='.$db_name;
        $this->db_name = $db_name;
        $this->host = $host;
        $this->driver = $driver;
        $this->db_user = $db_user;
        $this->db_pass = $db_pass;
        $this->conn = new Database($this->dsn,$this->db_user,$this->db_pass);
    }
    
    public function abstractDb($debugMode = false){
        
        $query = "SELECT * FROM information_schema.tables where table_schema='$this->db_name'";
        $result = $this->conn->select($query);
        $this->setTables($result,$debugMode);
        
    }
    
    public function generateAllClasses(string $output, $additionalParams = []){
        foreach ($this->tables as $table) {
            $this->generateClass($table, $output, $additionalParams);
        }
        print "\n All Classes generated @ $output";
    }
    
    private function setTables(array $tables, bool $debugMode){
        
        $this->tables = self::processTables($tables);
        if($debugMode){
            print "Table Count: ".count($this->tables);
            print "</br>Tables found:";
            print "<ul>";
            array_map(function($table){
                print "<li>".$table->getTableName()."</li>";
            },$this->tables);
            print "</ul>";
        }
    }
    
    public function generateClass(Table $table, string $output, $additionalParams = []){
        
        $attributes = $this->getTableAttr($table);
        $className = ucfirst($table->getTableName());
        $classFile = fopen($output.$className.".php", "w") or die("Permission "
                . "denied, try chmod 777 [outputFolder]");
        $content = "<?php\n\n/**\n* Class ".$className." generated by Chrysalis v.".
                $this->version."\n* \n* Chrysalis info:\n* @author pabhoz\n* git"
                . "hub: @pabhoz\n* bitbucket: @pabhoz\n* \n*/ \n \n";
        
        $extends = (isset($additionalParams["extends"])) ? "extends ".
                $additionalParams["extends"] : "";
        
        $content.= "class ".$className." $extends {\n\n";
        
        $parentConstruct = (isset($additionalParams["parent_construct"])) ? "\n        parent::__construct();\n":"";
        $constructor = "\n    public function __construct(";
        $constructorC = "";
        $getters = "";
        $setters = "";
        foreach ($attributes as $key => $attr) {
            $content.="    private $".$key.";\n";
            $constructor.= ($attr["key"])? " $".$key.", " : " ".$attr["type"]." $".$key.",";
            $constructorC .= "        ".'$this->'.$key.' = $'.$key.";\n";
            $getters .= "\n    public function get".ucfirst($key)."(): ".$attr["type"]." {"
                    . "\n        return ".'$this->'.$key.";\n    }\n";
            $setters .= "\n    public function set".ucfirst($key)."(".$attr["type"]." $$key) {"
                    . "\n        ".'$this->'.$key." = $$key;\n    }\n";
        }
        $content .= rtrim($constructor,",").") {\n";
        $content .= $parentConstruct.$constructorC."    }\n";
        $content .= $getters;
        $content .= $setters;
        
        $additionalMethods = (isset($additionalParams["additionalMethods"])) ? 
                $additionalParams["additionalMethods"] : [];
        
        foreach ($additionalMethods as $method) {
            $content .= "\n".$method;
        }
        
        $content.= "\n}";
        fwrite($classFile, $content);
        fclose($classFile);
        
    }
    
    private function getTableAttr(Table $table){
        $query = "DESCRIBE ".$table->getTableName();
        $result = $this->conn->select($query);
        $params = [];
        foreach ($result as $param) {
            $pkey = ($param["Key"] == "PRI") ? true : false;
            $null = ($param["Null"] != "NO")? true : false;
            $type = self::parseAttrType($param["Type"]);
            $params[$param["Field"]] = ["type"=>$type,"null"=>$null,"key"=>$pkey];
        }
        return  $params;
    }
    
    private static function parseAttrType($attr){
        $attr = explode("(", $attr)[0];
        
        if($attr == "int" || $attr == "smallint" || $attr == "dec" ||
           $attr == "numeric"){ return "int";}
        if($attr == "float" || $attr == "real" || $attr == "double"){ return "int";}
        
        return "string";
    }
    
    public static function processTables(array $tables): array{
        $pTables = [];
        foreach ($tables as $table) {
            $tableObj = self::instanciateWithArray($table, "Table");
            $pTables[] = $tableObj;
        }
        return $pTables;
    }
    
    public static function instanciateWithArray($args,$class) {

        if (count($args) > 1) {
            $refMethod = new ReflectionMethod($class, '__construct');
            $params = $refMethod->getParameters();
            $re_args = array();
            foreach ($params as $param) {
                if ($param->isPassedByReference()) {
                    $re_args[$param->getName()] = &$args[$param->getName()];
                } else {
                    $re_args[$param->getName()] = $args[$param->getName()];
                }
            }

            $refClass = new ReflectionClass($class);
            return $refClass->newInstanceArgs((array) $re_args);
        }
    }

}
